#!/usr/bin/env python3
"""
Copilot Prompt Catalog Renderer
================================
Reads prompts.json and generates catalog.md -- a human-readable reference
document with summary statistics, table of contents, and per-prompt
documentation sections.

Usage:
    python render_catalog.py
    python render_catalog.py --prompts path/to/prompts.json --output path/to/catalog.md
"""

import json
import sys
import argparse
from collections import Counter
from datetime import datetime, timezone
from pathlib import Path

# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------
SCRIPT_DIR = Path(__file__).resolve().parent
DEFAULT_PROMPTS = SCRIPT_DIR / "prompts.json"
DEFAULT_OUTPUT = SCRIPT_DIR / "catalog.md"

SEVERITY_BADGE = {
    "critical": "ðŸ”´ Critical",
    "high": "ðŸŸ  High",
    "medium": "ðŸŸ¡ Medium",
    "low": "ðŸŸ¢ Low",
}

FREQUENCY_BADGE = {
    "very-high": "â¬› Very High",
    "high": "ðŸ”· High",
    "medium": "ðŸ”¶ Medium",
    "low": "ðŸ”¹ Low",
    "rare": "â¬œ Rare",
}

SEVERITY_ORDER = ["critical", "high", "medium", "low"]
FREQUENCY_ORDER = ["very-high", "high", "medium", "low", "rare"]

# ---------------------------------------------------------------------------
# Rendering helpers
# ---------------------------------------------------------------------------

def load_prompts(path: Path) -> list[dict]:
    """Load and return the prompts array from JSON."""
    with open(path, "r", encoding="utf-8") as f:
        data = json.load(f)
    if not isinstance(data, list):
        raise ValueError("prompts.json must be a JSON array")
    return data


def slug(prompt_id: str) -> str:
    """Convert a prompt ID to a markdown anchor slug."""
    return prompt_id.lower().replace("-", "")


def render_header(prompts: list[dict]) -> str:
    """Render the document header and auto-generation notice."""
    now = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M UTC")
    return (
        f"# Copilot Prompt Library Catalog\n"
        f"\n"
        f"> **Auto-generated** by `render_catalog.py` on {now}.  \n"
        f"> Do not edit this file directly. Update `prompts.json` and re-run the renderer.\n"
        f"\n"
        f"This catalog contains **{len(prompts)} pre-built Copilot prompts** for automating\n"
        f"common Synapse-to-Fabric migration code fixes. Each prompt is designed to be\n"
        f"copy-pasted into GitHub Copilot Chat, Azure Data Studio Copilot, or any\n"
        f"LLM-powered coding assistant.\n"
    )


def render_summary(prompts: list[dict]) -> str:
    """Render summary statistics."""
    lines = [
        "---",
        "",
        "## Summary Statistics",
        "",
        f"| Metric | Value |",
        f"|--------|-------|",
        f"| Total prompts | {len(prompts)} |",
    ]

    # By category
    cat_counts = Counter(p["category"] for p in prompts)
    for cat in sorted(cat_counts):
        lines.append(f"| Category: {cat} | {cat_counts[cat]} |")

    # By severity
    sev_counts = Counter(p["severity"] for p in prompts)
    for sev in SEVERITY_ORDER:
        if sev in sev_counts:
            lines.append(f"| Severity: {SEVERITY_BADGE.get(sev, sev)} | {sev_counts[sev]} |")

    # By frequency
    freq_counts = Counter(p["frequency"] for p in prompts)
    for freq in FREQUENCY_ORDER:
        if freq in freq_counts:
            lines.append(f"| Frequency: {FREQUENCY_BADGE.get(freq, freq)} | {freq_counts[freq]} |")

    lines.append("")
    return "\n".join(lines)


def render_toc(prompts: list[dict]) -> str:
    """Render table of contents."""
    lines = [
        "---",
        "",
        "## Table of Contents",
        "",
    ]
    for p in prompts:
        pid = p["id"]
        name = p["patternName"]
        sev = SEVERITY_BADGE.get(p["severity"], p["severity"])
        lines.append(f"- [{pid}: {name}](#{slug(pid)}) â€” {sev}")

    lines.append("")
    return "\n".join(lines)


def render_prompt_section(p: dict) -> str:
    """Render a single prompt's documentation section."""
    pid = p["id"]
    sev = SEVERITY_BADGE.get(p["severity"], p["severity"])
    freq = FREQUENCY_BADGE.get(p["frequency"], p["frequency"])
    tags_str = " ".join(f"`{t}`" for t in p["tags"])
    related_str = ", ".join(f"[{r}](#{slug(r)})" for r in p["relatedPrompts"]) or "None"

    section = f"""---

## {pid}: {p["patternName"]}

**Category:** {p["category"]}
**Severity:** {sev}
**Frequency:** {freq}
**Tags:** {tags_str}

### Description

{p["description"]}

### When to Use

{p["whenToUse"]}

### Copilot Prompt

Copy the following prompt into your Copilot Chat along with the SQL code to transform:

```text
{p["promptText"]}
```

### Example

**Before** (Synapse):

```sql
{p["exampleBefore"]}
```

**After** (Fabric):

```sql
{p["exampleAfter"]}
```

### Expected Outcome

{p["expectedOutcome"]}

### Related Prompts

{related_str}
"""
    return section


def render_footer() -> str:
    """Render the document footer."""
    return (
        "---\n"
        "\n"
        "## Adding New Prompts\n"
        "\n"
        "1. Edit `prompts.json` and add a new entry following the schema in `prompts.schema.json`.\n"
        "2. Run `python validate.py` to verify the new entry passes all checks.\n"
        "3. Run `python render_catalog.py` to regenerate this catalog.\n"
        "\n"
        "---\n"
        "\n"
        "*Generated by the DMTSP Fabric Migration Assistant - Copilot Prompt Library*\n"
    )


# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------

def main() -> int:
    parser = argparse.ArgumentParser(description="Render Copilot Prompt Catalog")
    parser.add_argument("--prompts", type=Path, default=DEFAULT_PROMPTS,
                        help="Path to prompts.json")
    parser.add_argument("--output", type=Path, default=DEFAULT_OUTPUT,
                        help="Output path for catalog.md")
    args = parser.parse_args()

    print(f"Loading prompts from {args.prompts} ...")
    prompts = load_prompts(args.prompts)
    print(f"  Found {len(prompts)} prompts.")

    parts = [
        render_header(prompts),
        render_summary(prompts),
        render_toc(prompts),
    ]

    for p in prompts:
        parts.append(render_prompt_section(p))

    parts.append(render_footer())

    catalog = "\n".join(parts)

    with open(args.output, "w", encoding="utf-8") as f:
        f.write(catalog)

    print(f"  Catalog written to {args.output}")
    print(f"  Total size: {len(catalog):,} characters")
    return 0


if __name__ == "__main__":
    sys.exit(main())
